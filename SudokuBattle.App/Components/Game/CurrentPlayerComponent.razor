@using SudokuBattle.App.Models.Game
@using SudokuBattle.App.Services
@using SudokuBattle.Sudoku.Models
@inject IJSRuntime JsRuntime

<Interop Events='@( ["keyup"])'/>

<div class="d-flex flex-column align-items-center justify-content-center gap-4">
    <div class="fs-4 fw-semibold">
        @State.PlayerName
    </div>
    <div class="d-flex flex-column align-items-center justify-content-center">
        <GridComponent Grid="_displayGrid" GridSize="GridComponent.Size.Big" OnCellClicked="OnCellClicked" RowBorderColor="_rowBorderColors" ColumnBorderColor="_columnBorderColors" RegionBorderColor="_regionBorderColors"/>
    </div>
    <div class="controls d-flex gap-2 align-items-center justify-content-center">
        @if (_selectedCell.HasValue)
        {
            @if (_annotationMode)
            {
                <button class="btn btn-lg btn-outline-primary" @onclick="ToggleAnnotationMode">Element</button>

                <div class="mb-3">
                    <label for="elements" class="form-label">Annotations</label>
                    <div id="elements" class="input-group input-group-lg mb-3">
                        @for (int i = 1; i < 10; i++)
                        {
                            int element = i;
                            <button type="button" class="@GetAnnotationStyle(element)" onclick="@(() => ToggleSelectedCellAnnotation(element))">@element</button>
                        }
                        <button type="button" class="@GetAnnotationStyle(null)" @onclick="ClearSelectedCellAnnotations">
                            <i class="bi bi-x"></i>
                        </button>
                    </div>
                </div>

            }
            else
            {
                <div class="mb-3">
                    <label for="elements" class="form-label">Element</label>
                    <div id="elements" class="input-group input-group-lg mb-3">
                        @for (int i = 1; i < 10; i++)
                        {
                            int element = i;
                            <button type="button" class="@GetElementStyle(element)" onclick="@(() => SetSelectedCellElement(element))">@element</button>
                        }
                        <button type="button" class="@GetElementStyle(null)" onclick="@(() => SetSelectedCellElement(null))">
                            <i class="bi bi-x"></i>
                        </button>
                    </div>
                </div>

                <button class="btn btn-lg btn-outline-secondary" @onclick="ToggleAnnotationMode">Annotations</button>
            }
        }
    </div>
</div>

@code {

    GridComponent.Cell[,]? _displayGrid;
    GridComponent.Color[]? _rowBorderColors;
    GridComponent.Color[]? _columnBorderColors;
    GridComponent.Color[,]? _regionBorderColors;
    (int Row, int Column)? _selectedCell;
    bool _annotationMode;

    [Parameter]
    public required PlayerState State { get; set; }

    SudokuGame Game => State.Game;
    SudokuGrid Grid => State.Grid;

    protected override void OnInitialized()
    {
        UpdateGrid();
        Grid.CellValueChanged += OnCellValueChanged;
        Grid.CellAnnotationChanged += OnCellValueChanged;

        Interop.KeyupEvent += OnKeyPress;
    }

    string GetElementStyle(int? element)
    {
        string result = "btn ";

        if (Game.IsOver || !_selectedCell.HasValue)
        {
            result += "disabled";
        }
        else
        {
            SudokuCell cell = Grid[_selectedCell.Value.Row, _selectedCell.Value.Column];
            if (element.HasValue && cell.Element == element)
            {
                result += "btn-primary";
            }
            else
            {
                result += "btn-outline-secondary";
            }
        }

        return result;
    }

    string GetAnnotationStyle(int? element)
    {
        string result = "btn ";

        if (Game.IsOver || !_selectedCell.HasValue)
        {
            result += "disabled";
        }
        else
        {
            SudokuCell cell = Grid[_selectedCell.Value.Row, _selectedCell.Value.Column];
            if (element.HasValue && cell.Annotations.Contains(element.Value))
            {
                result += "btn-secondary";
            }
            else
            {
                result += "btn-outline-secondary";
            }
        }

        return result;
    }

    void ToggleAnnotationMode()
    {
        if (Game.IsOver)
        {
            return;
        }

        _ = InvokeAsync(
            () =>
            {
                _annotationMode = !_annotationMode;
                UpdateGrid();
                StateHasChanged();
            }
        );
    }

    void SetSelectedCellElement(int? element)
    {
        if (Game.IsOver || !_selectedCell.HasValue)
        {
            return;
        }

        SudokuCell selectedCell = Grid[_selectedCell.Value.Row, _selectedCell.Value.Column];
        selectedCell.Element = element;
    }

    void ToggleSelectedCellAnnotation(int element)
    {
        if (Game.IsOver || !_selectedCell.HasValue)
        {
            return;
        }

        SudokuCell selectedCell = Grid[_selectedCell.Value.Row, _selectedCell.Value.Column];
        if (selectedCell.Annotations.Contains(element))
        {
            selectedCell.Annotations.Remove(element);
        }
        else
        {
            selectedCell.Annotations.Add(element);
        }
    }

    void ClearSelectedCellAnnotations()
    {
        if (Game.IsOver || !_selectedCell.HasValue)
        {
            return;
        }

        SudokuCell selectedCell = Grid[_selectedCell.Value.Row, _selectedCell.Value.Column];
        selectedCell.Annotations.Clear();
    }

    void UpdateGrid()
    {
        if (_displayGrid == null)
        {
            _displayGrid = new GridComponent.Cell[Grid.Rows.Count, Grid.Columns.Count];
            for (int i = 0; i < Grid.Rows.Count; i++)
            for (int j = 0; j < Grid.Rows.Count; j++)
            {
                _displayGrid[i, j] = new GridComponent.Cell();
            }
        }

        foreach ((int row, int column, SudokuCell cell) in Grid.Enumerate())
        {
            _displayGrid[row, column].Content = $"{cell.Element}";
            _displayGrid[row, column].Annotation = string.Join(", ", cell.Annotations);
            _displayGrid[row, column].BackgroundColor = cell.Locked ? GridComponent.Color.LightGrey : GridComponent.Color.None;
            _displayGrid[row, column].Border = _selectedCell == (row, column) ? _annotationMode ? GridComponent.Color.Grey : GridComponent.Color.Yellow : GridComponent.Color.None;
        }

        if (_rowBorderColors == null)
        {
            _rowBorderColors = Enumerable.Range(0, 9).Select(_ => GridComponent.Color.None).ToArray();
        }

        for (int i = 0; i < Grid.Rows.Count; i++)
        {
            SudokuRow row = Grid.Rows[i];
            _rowBorderColors[i] = row is { IsCompleted: true, IsValid: false } ? GridComponent.Color.Red : GridComponent.Color.None;
        }

        if (_columnBorderColors == null)
        {
            _columnBorderColors = Enumerable.Range(0, 9).Select(_ => GridComponent.Color.None).ToArray();
        }

        for (int i = 0; i < Grid.Columns.Count; i++)
        {
            SudokuColumn column = Grid.Columns[i];
            _columnBorderColors[i] = column is { IsCompleted: true, IsValid: false } ? GridComponent.Color.Red : GridComponent.Color.None;
        }

        if (_regionBorderColors == null)
        {
            _regionBorderColors = new[,]
            {
                { GridComponent.Color.None, GridComponent.Color.None, GridComponent.Color.None },
                { GridComponent.Color.None, GridComponent.Color.None, GridComponent.Color.None },
                { GridComponent.Color.None, GridComponent.Color.None, GridComponent.Color.None }
            };
        }

        for (int i = 0; i < Grid.Regions.Count; i++)
        {
            SudokuRegion region = Grid.Regions[i];
            _regionBorderColors[region.Row, region.Column] = region is { IsCompleted: true, IsValid: false } ? GridComponent.Color.Red : GridComponent.Color.None;
        }
    }

    void OnCellClicked((int Row, int Column) cell)
    {
        if (_selectedCell == cell || Grid[cell.Row, cell.Column].Locked)
        {
            _selectedCell = null;
        }
        else
        {
            _selectedCell = cell;
        }

        UpdateGrid();
        StateHasChanged();
    }

    void OnCellValueChanged(object? sender, SudokuCell e) =>
        _ = InvokeAsync(
            () =>
            {
                UpdateGrid();
                StateHasChanged();
            }
        );

    void OnKeyPress(object? _, KeyboardEventArgs args)
    {
        if (args.Code is "ControlLeft" or "ControlRight" or "ShiftLeft" or "ShiftRight")
        {
            ToggleAnnotationMode();
            return;
        }

        if (!TryGetElementFromCode(args.Code, out int? element))
        {
            return;
        }

        if (_annotationMode)
        {
            if (element.HasValue)
            {
                ToggleSelectedCellAnnotation(element.Value);
            }
            else
            {
                ClearSelectedCellAnnotations();
            }
        }
        else
        {
            SetSelectedCellElement(element);
        }
    }

    bool TryGetElementFromCode(string code, out int? element)
    {
        switch (code)
        {
            case "Digit0":
            case "Numpad0":
                element = 0;
                return true;
            case "Digit1":
            case "Numpad1":
                element = 1;
                return true;
            case "Digit2":
            case "Numpad2":
                element = 2;
                return true;
            case "Digit3":
            case "Numpad3":
                element = 3;
                return true;
            case "Digit4":
            case "Numpad4":
                element = 4;
                return true;
            case "Digit5":
            case "Numpad5":
                element = 5;
                return true;
            case "Digit6":
            case "Numpad6":
                element = 6;
                return true;
            case "Digit7":
            case "Numpad7":
                element = 7;
                return true;
            case "Digit8":
            case "Numpad8":
                element = 8;
                return true;
            case "Digit9":
            case "Numpad9":
                element = 9;
                return true;
            case "Escape":
            case "Backspace":
                element = null;
                return true;
            default:
                element = null;
                return false;
        }
    }

}