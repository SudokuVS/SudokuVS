@inject IJSRuntime JsRuntime;
@implements IAsyncDisposable

<script>
    function keyupCallback(args) {
        DotNet.invokeMethodAsync("SudokuBattle.App", "FireKeyupEvent", {
            key: args.key,
            code: args.code,
            location: args.location,
            repeat: args.repeat,
            ctrlKey: args.ctrlKey,
            shiftKey: args.shiftKey,
            altKey: args.altKey,
            metaKey: args.metaKey,
            type: args.type,
        }); 
    }
    
    window.interopAddKeyupEventListener = () => window.addEventListener("keyup", keyupCallback);
    window.interopRemoveEventListener = () => window.removeEventListener("keyup", keyupCallback)

</script>

@code {

    private bool _subscribed;

    [Parameter]
    public string[] Events { get; set; } = [];

    public static event EventHandler<KeyboardEventArgs>? KeyupEvent;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        IEnumerable<string> callbacks = Events.Select(GetAddListenerName).OfType<string>();

        foreach (string callback in callbacks)
        {
            await JsRuntime.InvokeVoidAsync(callback);
        }

        _subscribed = true;
    }

    public async ValueTask DisposeAsync()
    {
        if (!_subscribed)
        {
            return;
        }

        IEnumerable<string> callbacks = Events.Select(GetRemoveListenerName).OfType<string>();

        foreach (string callback in callbacks)
        {
            await JsRuntime.InvokeVoidAsync(callback);
        }
    }

    string? GetAddListenerName(string evt) =>
        evt switch
        {
            "keyup" => "interopAddKeyupEventListener",
            _ => ""
        };

    string? GetRemoveListenerName(string evt) =>
        evt switch
        {
            "keyup" => "interopRemoveKeyupEventListener",
            _ => null
        };

    [JSInvokable]
    public static Task FireKeyupEvent(KeyboardEventArgs args)
    {
        KeyupEvent?.Invoke(null, args);
        return Task.CompletedTask;
    }

}