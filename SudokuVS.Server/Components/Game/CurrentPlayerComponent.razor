@using SudokuVS.Game
@using SudokuVS.Sudoku.Models
@inject IJSRuntime JsRuntime

<Interop @ref="_interop" Events='@( ["keyup"])'/>

<div class="d-flex flex-column align-items-center justify-content-center gap-4">
    <div class="fs-4 fw-semibold">
        @State.PlayerName
    </div>
    <div class="w-100 d-flex align-items-start gap-4 px-4">
        <div class="flex-grow-1">
        </div>
        <div>
            <GridComponent Grid="_displayGrid" GridSize="GridComponent.Size.Big" OnCellClicked="OnCellClicked" OnCellRightClicked="OnCellRightClicked" RowBorderColor="_rowBorderColors" ColumnBorderColor="_columnBorderColors" RegionBorderColor="_regionBorderColors"/>
        </div>
        <div class="flex-grow-1 d-flex flex-column">
            <div class="fs-4 mb-3">
                Progress
            </div>
            <div class="mb-1">
                <GridTotalProgressComponent Grid="Grid" ProgressBarColor="GridTotalProgressComponent.Color.Blue"/>
            </div>
            @for (int i = 1; i <= 9; i++)
            {
                <div class="mb-1">
                    <GridElementProgressComponent Grid="Grid" Element="i"/>
                </div>
            }
        </div>
    </div>
    <div class="controls d-flex gap-2 align-items-center justify-content-center">
        @if (_selectedCell.HasValue && !_selectedCellLocked)
        {
            @if (_annotationMode)
            {
                <button class="btn btn-lg btn-outline-primary" @onclick="ToggleAnnotationMode">Element</button>

                <div class="mb-3">
                    <label for="elements" class="form-label">Annotations</label>
                    <div id="elements" class="input-group input-group-lg mb-3">
                        @for (int i = 1; i < 10; i++)
                        {
                            int element = i;
                            <button type="button" class="@GetAnnotationStyle(element)" onclick="@(() => ToggleSelectedCellAnnotation(element))">@element</button>
                        }
                        <button type="button" class="@GetAnnotationStyle(null)" @onclick="ClearSelectedCellAnnotations">
                            <i class="bi bi-x"></i>
                        </button>
                    </div>
                </div>
            }
            else
            {
                <div class="mb-3">
                    <label for="elements" class="form-label">Element</label>
                    <div id="elements" class="input-group input-group-lg mb-3">
                        @for (int i = 1; i < 10; i++)
                        {
                            int element = i;
                            <button type="button" class="@GetElementStyle(element)" onclick="@(() => SetSelectedCellElement(element))">@element</button>
                        }
                        <button type="button" class="@GetElementStyle(null)" onclick="@(() => SetSelectedCellElement(null))">
                            <i class="bi bi-x"></i>
                        </button>
                    </div>
                </div>

                <button class="btn btn-lg btn-outline-secondary" @onclick="ToggleAnnotationMode">Annotations</button>
            }

            @if (Game.Options.MaxHints > 0 && !IsHint(_selectedCell.Value.Row, _selectedCell.Value.Column))
            {
                <button class="btn btn-lg btn-outline-secondary" @onclick="UseHintAtSelectedCell" disabled="@(State.RemainingHints <= 0)">
                    Hint @State.RemainingHints / @Game.Options.MaxHints
                </button>
            }
        }
    </div>
</div>

@code {

    Interop? _interop;
    GridComponent.Cell[,]? _displayGrid;
    GridComponent.Color[]? _rowBorderColors;
    GridComponent.Color[]? _columnBorderColors;
    GridComponent.Color[,]? _regionBorderColors;
    (int Row, int Column)? _selectedCell;
    bool _selectedCellLocked;
    bool _annotationMode;

    [Parameter]
    public required PlayerState State { get; set; }

    SudokuGame Game => State.Game;
    SudokuGrid Grid => State.Grid;

    protected override void OnInitialized()
    {
        UpdateGrid();
        Grid.CellValueChanged += OnStateChanged;
        Grid.CellAnnotationChanged += OnStateChanged;
        Grid.CellLockChanged += OnStateChanged;
        State.HintAdded += OnStateChanged;
    }

    protected override void OnAfterRender(bool firstRender)
    {
        if (!firstRender)
        {
            return;
        }

        if (_interop is not null)
        {
            _interop.KeyupEvent += OnKeyPress;
        }
    }

    string GetElementStyle(int? element)
    {
        string result = "btn ";

        if (Game.IsOver || !_selectedCell.HasValue || _selectedCellLocked)
        {
            result += "disabled";
        }
        else
        {
            SudokuCell cell = Grid[_selectedCell.Value.Row, _selectedCell.Value.Column];
            if (element.HasValue && cell.Element == element)
            {
                result += "btn-primary";
            }
            else
            {
                result += "btn-outline-secondary";
            }
        }

        return result;
    }

    string GetAnnotationStyle(int? element)
    {
        string result = "btn ";

        if (Game.IsOver || !_selectedCell.HasValue || _selectedCellLocked)
        {
            result += "disabled";
        }
        else
        {
            SudokuCell cell = Grid[_selectedCell.Value.Row, _selectedCell.Value.Column];
            if (element.HasValue && cell.Annotations.Contains(element.Value))
            {
                result += "btn-secondary";
            }
            else
            {
                result += "btn-outline-secondary";
            }
        }

        return result;
    }

    void ToggleAnnotationMode()
    {
        if (Game.IsOver)
        {
            return;
        }

        _annotationMode = !_annotationMode;
        TriggerUpdate();
    }

    void SetSelectedCellElement(int? element)
    {
        if (Game.IsOver || !_selectedCell.HasValue || _selectedCellLocked)
        {
            return;
        }

        if (element.HasValue)
        {
            State.SetElement(_selectedCell.Value.Row, _selectedCell.Value.Column, element.Value);
        }
        else
        {
            State.ClearElement(_selectedCell.Value.Row, _selectedCell.Value.Column);
        }
    }

    void ToggleSelectedCellAnnotation(int element)
    {
        if (Game.IsOver || !_selectedCell.HasValue || _selectedCellLocked)
        {
            return;
        }

        State.ToggleAnnotation(_selectedCell.Value.Row, _selectedCell.Value.Column, element);
    }

    void ClearSelectedCellAnnotations()
    {
        if (Game.IsOver || !_selectedCell.HasValue || _selectedCellLocked)
        {
            return;
        }

        State.ClearAnnotation(_selectedCell.Value.Row, _selectedCell.Value.Column);
    }

    void UseHintAtSelectedCell()
    {
        if (Game.IsOver || !_selectedCell.HasValue || _selectedCellLocked)
        {
            return;
        }

        State.UseHint(_selectedCell.Value.Row, _selectedCell.Value.Column);
    }

    void UpdateGrid()
    {
        if (_displayGrid == null)
        {
            _displayGrid = new GridComponent.Cell[Grid.Rows.Count, Grid.Columns.Count];
            for (int i = 0; i < Grid.Rows.Count; i++)
            for (int j = 0; j < Grid.Rows.Count; j++)
            {
                _displayGrid[i, j] = new GridComponent.Cell();
            }
        }

        foreach ((int row, int column, SudokuCell cell) in Grid.Enumerate())
        {
            _displayGrid[row, column].Content = $"{cell.Element}";
            _displayGrid[row, column].Annotation = cell.Element is null ? string.Join(", ", cell.Annotations) : null;
            _displayGrid[row, column].FontStyle = _selectedCell.HasValue && Grid[_selectedCell.Value.Row, _selectedCell.Value.Column].Element == cell.Element ? GridComponent.FontStyle.Bold : GridComponent.FontStyle.None;
            _displayGrid[row, column].BackgroundColor = IsHint(cell.Row, cell.Column)
                ? GridComponent.Color.Yellow
                : cell.IsLocked
                    ? GridComponent.Color.LightGrey
                    : GridComponent.Color.None;
            _displayGrid[row, column].Border = _selectedCell == (row, column) ? _annotationMode ? GridComponent.Color.Grey : GridComponent.Color.Yellow : GridComponent.Color.None;

        }

        if (_rowBorderColors == null)
        {
            _rowBorderColors = Enumerable.Range(0, 9).Select(_ => GridComponent.Color.None).ToArray();
        }

        for (int i = 0; i < Grid.Rows.Count; i++)
        {
            SudokuRow row = Grid.Rows[i];
            _rowBorderColors[i] = row is { IsCompleted: true, IsValid: false } ? GridComponent.Color.Red : GridComponent.Color.None;
        }

        if (_columnBorderColors == null)
        {
            _columnBorderColors = Enumerable.Range(0, 9).Select(_ => GridComponent.Color.None).ToArray();
        }

        for (int i = 0; i < Grid.Columns.Count; i++)
        {
            SudokuColumn column = Grid.Columns[i];
            _columnBorderColors[i] = column is { IsCompleted: true, IsValid: false } ? GridComponent.Color.Red : GridComponent.Color.None;
        }

        if (_regionBorderColors == null)
        {
            _regionBorderColors = new[,]
            {
                { GridComponent.Color.None, GridComponent.Color.None, GridComponent.Color.None },
                { GridComponent.Color.None, GridComponent.Color.None, GridComponent.Color.None },
                { GridComponent.Color.None, GridComponent.Color.None, GridComponent.Color.None }
            };
        }

        for (int i = 0; i < Grid.Regions.Count; i++)
        {
            SudokuRegion region = Grid.Regions[i];
            _regionBorderColors[region.Row, region.Column] = region is { IsCompleted: true, IsValid: false } ? GridComponent.Color.Red : GridComponent.Color.None;
        }
    }

    bool IsHint(int row, int column) => State.Hints.Contains((row, column));

    void OnCellClicked((int Row, int Column) cell)
    {
        SelectCell(cell);
        _annotationMode = false;

        UpdateGrid();
        StateHasChanged();
    }

    void OnCellRightClicked((int Row, int Column) cell)
    {
        SelectCell(cell);
        _annotationMode = true;

        UpdateGrid();
        StateHasChanged();
    }

    void SelectCell((int Row, int Column) cell)
    {

        SudokuCell c = Grid[cell.Row, cell.Column];
        _selectedCell = cell;
        _selectedCellLocked = c.IsLocked;
    }

    void OnStateChanged(object? sender, (int, int) __) => TriggerUpdate();
    void OnStateChanged(object? sender, EventArgs __) => TriggerUpdate();

    void TriggerUpdate() =>
        _ = InvokeAsync(
            () =>
            {
                UpdateGrid();
                StateHasChanged();
            }
        );

    void OnKeyPress(object? _, KeyboardEventArgs args)
    {
        if (args.Code is "ControlLeft" or "ControlRight" or "ShiftLeft" or "ShiftRight")
        {
            ToggleAnnotationMode();
            return;
        }

        if (!TryGetElementFromCode(args.Code, out int? element))
        {
            return;
        }

        if (_annotationMode)
        {
            if (element.HasValue)
            {
                ToggleSelectedCellAnnotation(element.Value);
            }
            else
            {
                ClearSelectedCellAnnotations();
            }
        }
        else
        {
            SetSelectedCellElement(element);
        }
    }

    bool TryGetElementFromCode(string code, out int? element)
    {
        switch (code)
        {
            case "Digit0":
            case "Numpad0":
                element = 0;
                return true;
            case "Digit1":
            case "Numpad1":
                element = 1;
                return true;
            case "Digit2":
            case "Numpad2":
                element = 2;
                return true;
            case "Digit3":
            case "Numpad3":
                element = 3;
                return true;
            case "Digit4":
            case "Numpad4":
                element = 4;
                return true;
            case "Digit5":
            case "Numpad5":
                element = 5;
                return true;
            case "Digit6":
            case "Numpad6":
                element = 6;
                return true;
            case "Digit7":
            case "Numpad7":
                element = 7;
                return true;
            case "Digit8":
            case "Numpad8":
                element = 8;
                return true;
            case "Digit9":
            case "Numpad9":
                element = 9;
                return true;
            case "Escape":
            case "Backspace":
                element = null;
                return true;
            default:
                element = null;
                return false;
        }
    }

}